<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Ranking - Debate Taquara Raiz</title>
  <link rel="stylesheet" href="/static/style.css">
  <script>
  // Expand/collapse ranking cards
  function toggleCard(id) {
    const body = document.getElementById('card-body-'+id);
    if (body.style.display === 'block') {
      body.style.display = 'none';
    } else {
      body.style.display = 'block';
    }
  }
  </script>
</head>
<body>
  <header>
    <div class="logo-container">
      <img src="/static/taquarada_logo.png" alt="Portal Taquarada">
      <img src="/static/boneco.png" alt="Boneco Taquarada">
    </div>
    <nav>
      <ul>
        <li><a href="/">Classificação</a></li>
        <li><a href="/palpites">Palpites</a></li>
        <li><a href="/ranking" class="active">Ranking</a></li>
        <li><a href="/resultados">Resultados</a></li>
        <li><a href="/artilharia">Artilharia</a></li>
        {{admin_link}}
        {{auth_link}}
      </ul>
    </nav>
  </header>
  <main>
    <h2>Ranking de Apresentadores</h2>
    <p>O ranking é calculado da seguinte forma: 3 pontos para placar exato, 1 ponto para resultado correto e 0 ponto para erro.</p>
    <!-- Seletor de rodada: permite ver o ranking geral ou por rodada -->
    {{round_selector}}
    {{ranking_cards}}

    <!-- Gráfico de evolução dos apresentadores -->
    <div class="chart-wrapper" style="margin-top:2rem; position: relative;">
      <h3>Evolução dos apresentadores por rodada</h3>
      <img src="/static/heineken_premio.webp" alt="Prêmio Heineken" style="position: absolute; top: 50px; right: 20px; width: 80px; height: auto; opacity: 0.8; z-index: 10;">
      <canvas id="ranking-chart" width="900" height="400" style="max-width:100%;"></canvas>
    </div>
    <script>
    // Dados de evolução injetados pelo servidor. Contém o array de rodadas e as séries de cada apresentador.
    const chartData = {{chart_data}};
    (function() {
      if (!chartData || !chartData.rounds || !chartData.series) return;
      const canvas = document.getElementById('ranking-chart');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const rounds = chartData.rounds;
      const series = chartData.series;
      const users = Object.keys(series);
      // Paleta de cores para até 6 apresentadores
      const palette = ['#FF6B6B','#4D96FF','#FFC75F','#845EC2','#00C49A','#8B5CF6'];
      // Calcular valor máximo para escala Y
      let maxVal = 0;
      users.forEach(u => {
        series[u].forEach(v => { if (v > maxVal) maxVal = v; });
      });
      if (maxVal === 0) maxVal = 1;
      const width = canvas.width;
      const height = canvas.height;
      const padding = 40;
      const plotWidth = width - padding * 2;
      const plotHeight = height - padding * 2;
      const xStep = plotWidth / (rounds.length - 1);
      const yScale = plotHeight / maxVal;

      // Precompute coordinates for each series to avoid recalculation during animation
      const seriesCoords = {};
      users.forEach((user, idx) => {
        const vals = series[user];
        const coords = vals.map((val, i) => {
          const x = padding + xStep * i;
          const y = height - padding - (val * yScale);
          return { x, y };
        });
        seriesCoords[user] = coords;
      });

      // Draw static axes and labels
      function drawAxes() {
        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = '#cccccc';
        ctx.lineWidth = 1;
        // Y axis
        ctx.beginPath();
        ctx.moveTo(padding, padding);
        ctx.lineTo(padding, height - padding);
        ctx.stroke();
        // X axis
        ctx.beginPath();
        ctx.moveTo(padding, height - padding);
        ctx.lineTo(width - padding, height - padding);
        ctx.stroke();
        // Y axis ticks and labels (5 divisions)
        const divisions = 5;
        ctx.fillStyle = '#444444';
        ctx.font = '12px sans-serif';
        for (let i = 0; i <= divisions; i++) {
          const yVal = (maxVal / divisions) * i;
          const y = height - padding - (yVal * yScale);
          ctx.beginPath();
          ctx.moveTo(padding - 5, y);
          ctx.lineTo(padding + 5, y);
          ctx.stroke();
          ctx.fillText(Math.round(yVal), padding - 30, y + 4);
        }
        // X axis ticks and labels
        rounds.forEach((r, idx) => {
          const x = padding + xStep * idx;
          ctx.beginPath();
          ctx.moveTo(x, height - padding - 5);
          ctx.lineTo(x, height - padding + 5);
          ctx.stroke();
          ctx.fillText(r, x - 5, height - padding + 20);
        });
      }
      // Draw lines up to a fractional progress (0..1)
      function drawLines(progress) {
        users.forEach((user, idx) => {
          const coords = seriesCoords[user];
          const color = palette[idx % palette.length];
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.beginPath();
          const totalSegments = coords.length - 1;
          const prog = progress * totalSegments;
          const currentIndex = Math.floor(prog);
          const frac = prog - currentIndex;
          coords.forEach((pt, i) => {
            if (i === 0) {
              ctx.moveTo(pt.x, pt.y);
            } else if (i <= currentIndex) {
              ctx.lineTo(pt.x, pt.y);
            } else if (i === currentIndex + 1) {
              // draw partial segment
              const prev = coords[i - 1];
              const dx = pt.x - prev.x;
              const dy = pt.y - prev.y;
              ctx.lineTo(prev.x + dx * frac, prev.y + dy * frac);
            }
          });
          ctx.stroke();
          // draw label at end of current visible line
          const labelPtIndex = Math.min(currentIndex + 1, coords.length - 1);
          const labelPt = coords[labelPtIndex];
          ctx.fillStyle = color;
          ctx.fillText(user, labelPt.x + 5, labelPt.y + 4);
        });
      }
      // Animation loop with adjustable speed and pause at the end
      // Speed factor: 0.003 gives roughly 30% of the original 0.01 increment
      const speed = 0.003;
      // Pause duration in milliseconds (10 seconds)
      const pauseDuration = 10000;
      let progress = 0;
      let paused = false;
      function animate() {
        // Only advance progress if not paused
        if (!paused) {
          progress += speed;
          // When the lines are fully drawn, hold for the pause duration
          if (progress >= 1) {
            progress = 1;
            paused = true;
            // After the pause, reset progress and resume animation
            setTimeout(() => {
              progress = 0;
              paused = false;
            }, pauseDuration);
          }
        }
        // Always redraw axes and current state of lines
        drawAxes();
        drawLines(progress);
        requestAnimationFrame(animate);
      }
      // Initial draw and start animation
      drawAxes();
      animate();
    })();
    </script>
  </main>
  <footer>
    <p>&copy; 2025 Debate Taquara Raiz</p>
  </footer>
</body>
</html>
